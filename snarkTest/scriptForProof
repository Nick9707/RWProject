1. generate ptau
snarkjs powersoftau new bn128 14 pot14_0000.ptau -v

2. Create new contribution
snarkjs powersoftau contribute pot14_0000.ptau pot14_0001.ptau --name="First contribution" -v -e="someText"
This will get new ptau file with new contribution

3.Add second contribution
snarkjs powersoftau contribute pot14_0001.ptau pot14_0002.ptau --name="Second contribution" -v -e="some random text"

4. Provide a third contribution using third party software
snarkjs powersoftau export challenge pot14_0002.ptau challenge_0003
snarkjs powersoftau challenge contribute bn128 challenge_0003 response_0003 -e="some random text"
snarkjs powersoftau import response pot14_0002.ptau response_0003 pot14_0003.ptau -n="Third contribution name"
This allows you to use different types of software in a single ceremony.

5. Verify the protocol so far
snarkjs powersoftau verify pot14_0003.ptau
Should get everything OK

6. Apply a random beacon
snarkjs powersoftau beacon pot14_0003.ptau pot14_beacon.ptau 0102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f 10 -n="Final Beacon"
This will add some randomness to the ptau file. The hash is comping from the future expected hash of eth transaction

7. Prepare phase 2
snarkjs powersoftau prepare phase2 pot14_beacon.ptau pot14_final.ptau -v
Under the hood, the prepare phase2 command calculates the encrypted evaluation of the Lagrange polynomials at tau for tau, alpha*tau and beta*tau.
It takes the beacon ptau file we generated in the previous step, and outputs a final ptau file which will be used to generate the circuit proving and verification keys.

8. Verify the final ptau
snarkjs powersoftau verify pot14_final.ptau

9. Create the circuit (circuit.circom)
pragma circom 2.0.0;

include "../node_modules/circomlib/circuits/poseidon.circom";

template PoseidonHasher() {
    signal input in;
    signal output out;

    component poseidon = Poseidon(1);
    poseidon.inputs[0] <== in;
    out <== poseidon.out;
}

component main = PoseidonHasher();
We create a circom file that allows us to easily test the system with a different number of constraints.

In this case, we've chosen 1000, but we can change this to anything we want (as long as the value we choose is below the number we defined in step 1).

10.Compile the circuit
circom circuit.circom --r1cs --wasm --sym
The circom command takes one input (the circuit to compile, in our case circuit.circom) and three options:
r1cs: generates circuit.r1cs (the r1cs constraint system of the circuit in binary format).
wasm: generates circuit.wasm (the wasm code to generate the witness â€“ more on that later).
sym: generates circuit.sym (a symbols file required for debugging and printing the constraint system in an annotated mode).

11. View information about the circuit
snarkjs r1cs info circuit.r1cs
The info command is used to print circuit stats.

12. Print the constraints
snarkjs r1cs print circuit.r1cs circuit.sym
To double check, we print the constraints of the circuit.
You should see a thousand constraints of the form:
[ -main.int[i] ] * [ main.int[i] ] - [ main.b -main.int[i+1] ] = 0

13. Export r1cs to json
snarkjs r1cs export json circuit.r1cs circuit.r1cs.json
We export r1cs to json format to make it human readable.

14. Calculate the witness / create input.json
{ "in": 98669788754841316848590328876098484119242743596215866921846548824 }

Calculate the witness from the circuit_js folder
node generate_witness.js circuit.wasm ../input.json ../witness.wtns
Check witness
cd..
snarkjs wtns check circuit.r1cs witness.wtns

15. Setup
snarkjs groth16 setup circuit.r1cs pot14_final.ptau circuit_0000.zkey
This generates the reference zkey without phase 2 contributions
IMPORTANT: Do not use this zkey in production, as it's not safe. It requires at least a contribution

16. Contribute to the phase 2 ceremony
snarkjs zkey contribute circuit_0000.zkey circuit_0001.zkey --name="1st Contributor Name" -v -e="someText"
The zkey contribute command creates a zkey file with a new contribution.

17. Provide a second contribution
snarkjs zkey contribute circuit_0001.zkey circuit_0002.zkey --name="Second contribution Name" -v -e="Another random entropy"

18. Provide a third contribution using third party software
snarkjs zkey export bellman circuit_0002.zkey  challenge_phase2_0003
snarkjs zkey bellman contribute bn128 challenge_phase2_0003 response_phase2_0003 -e="some random text"
snarkjs zkey import bellman circuit_0002.zkey response_phase2_0003 circuit_0003.zkey -n="Third contribution name"

19. Verify the latest zkey
snarkjs zkey verify circuit.r1cs pot14_final.ptau circuit_0003.zkey
We verify the zkey file we created in the previous step. Which means we check all the contributions to the second phase of the multi-party computation (MPC) up to that point.

20. Apply a random beacon
The zkey beacon command creates a zkey file with a contribution applied in the form of a random beacon.
We use it to apply a random beacon to the latest zkey after the final contribution has been made (this is necessary in order to generate a final zkey file and finalise phase 2 of the trusted setup).

21. Verify the final zkey
snarkjs zkey verify circuit.r1cs pot14_final.ptau circuit_final.zkey

22. Export the verification key to json
snarkjs zkey export verificationkey circuit_final.zkey verification_key.json

23. Create the proof
snarkjs groth16 prove circuit_final.zkey witness.wtns proof.json public.json
We create the proof. this command generates the files proof.json and public.json: proof.json contains the actual proof, whereas public.json contains the values of the public inputs and output.

24. Verify the proof
snarkjs groth16 verify verification_key.json public.json proof.json

25. Turn the verifier into a smart contract
snarkjs zkey export solidityverifier circuit_final.zkey verifier.sol




